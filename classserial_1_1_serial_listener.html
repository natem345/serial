<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>serial: serial::SerialListener Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">serial
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Cross-platformserialportlibraryforC++</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceserial.html">serial</a>      </li>
      <li class="navelem"><a class="el" href="classserial_1_1_serial_listener.html">SerialListener</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">serial::SerialListener Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="serial::SerialListener" -->
<p><code>#include &lt;<a class="el" href="serial__listener_8h_source.html">serial_listener.h</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a1a6fb318bff3269df63309d9d442738a">SerialListener</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a235ede7ea8530364d6510f0a2de068b3">~SerialListener</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a0cc4f2509f44a60b08422c1fd46c87a5">setTokenizer</a> (<a class="el" href="namespaceserial.html#a71c86cd8a6283d8015a7941890d38ba3">TokenizerType</a> tokenizer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a54613d3c6ffa4015db14e5ca95f0d541">setChunkSize</a> (size_t chunk_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#aa17f7ac85c36e59c61d443f98736a8d9">startListening</a> (<a class="el" href="classserial_1_1_serial.html">serial::Serial</a> &amp;serial_port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a7587b228f9327d9c0c6b83d46a932f93">stopListening</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceserial.html#acf64ada2e2976afe74771b22e738510b">FilterPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a62c0003bdaca5670eaf7d2c38273e3be">createFilter</a> (<a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a> comparator, <a class="el" href="namespaceserial.html#a32362eeeed30a7d8ccadf5204e07ca2e">DataCallback</a> callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceserial.html#a99b797cbc8375c64b5e100c5f0350198">BlockingFilterPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a75d4f93598f17352072c3fc03a8a3bdb">createBlockingFilter</a> (<a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a> comparator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceserial.html#a9e39a50ed4648208addac53759378497">BufferedFilterPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#ac8637a6cda1ffbf415a28d4838fb2abf">createBufferedFilter</a> (<a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a> comparator, size_t buffer_size=1024)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#afaea45fa5ef9c172dcd6b30f65bbc065">removeFilter</a> (<a class="el" href="namespaceserial.html#acf64ada2e2976afe74771b22e738510b">FilterPtr</a> filter_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#aa231e15eb061b74e165b96a2c68548c8">removeFilter</a> (<a class="el" href="namespaceserial.html#a99b797cbc8375c64b5e100c5f0350198">BlockingFilterPtr</a> blocking_filter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a15b39e4392cf4cec1e1b08e4f198e5fd">removeFilter</a> (<a class="el" href="namespaceserial.html#a9e39a50ed4648208addac53759378497">BufferedFilterPtr</a> buffered_filter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#ac9310aed9039d060bb72caf7d1a19fa1">removeAllFilters</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#ac71a68d0a96799b30ef4cbadbbb5a020">setDefaultHandler</a> (<a class="el" href="namespaceserial.html#a32362eeeed30a7d8ccadf5204e07ca2e">DataCallback</a> default_handler)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a247714b1dbf65ee6d74418a1990a4062">setInfoHandler</a> (<a class="el" href="namespaceserial.html#af0057921550e0544822f8cc552c77e05">LoggingCallback</a> info_handler)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a7e130dedfb5e934ced941df64726b5c8">setDebugHandler</a> (<a class="el" href="namespaceserial.html#af0057921550e0544822f8cc552c77e05">LoggingCallback</a> debug_handler)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#ac7094b1def26041f92f05c1c4a1d65c9">setWarningHandler</a> (<a class="el" href="namespaceserial.html#af0057921550e0544822f8cc552c77e05">LoggingCallback</a> warning_handler)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#ab2248f5520af44280175104d42729713">sleep</a> (long milliseconds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceserial.html#a71c86cd8a6283d8015a7941890d38ba3">TokenizerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#ae71cef30bed4a80148e7480904d8852f">delimeter_tokenizer</a> (std::string delimeter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a091cb7d1f6c53761abb832c914a4da38">exactly</a> (std::string exact_str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#ac6039844ba46665ed83e3885849b4d1d">startsWith</a> (std::string prefix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a22d8e22dbe6f3d35a7863c9279c4af68">endsWith</a> (std::string postfix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserial_1_1_serial_listener.html#a178ac4d1d2651341d96dc6a2d201629b">contains</a> (std::string substr)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Listens to a serial port, facilitates asynchronous reading </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1a6fb318bff3269df63309d9d442738a"></a><!-- doxytag: member="serial::SerialListener::SerialListener" ref="a1a6fb318bff3269df63309d9d442738a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SerialListener::SerialListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new <a class="el" href="classserial_1_1_serial.html">Serial</a> Listener. </p>
<div class="fragment"><pre class="fragment">                               : listening(<span class="keyword">false</span>), chunk_size_(5) {
  <span class="comment">// Set default callbacks</span>
  this-&gt;handle_exc = <a class="code" href="serial__listener_8cc.html#aacc17eba12b4fac7ac961382130feffe">defaultExceptionCallback</a>;
  this-&gt;info = <a class="code" href="serial__listener_8cc.html#ab0b707d2abc516fade2cd613d8dad48d">defaultInfoCallback</a>;
  this-&gt;debug = <a class="code" href="serial__listener_8cc.html#a20b31920479cf3b20e0f785b086ac5e2">defaultDebugCallback</a>;
  this-&gt;warn = <a class="code" href="serial__listener_8cc.html#ad8b32fe8d229791e7ef8d36109ff8ba5">defaultWarningCallback</a>;

  <span class="comment">// Default handler stuff</span>
  this-&gt;_default_handler = NULL;
  this-&gt;default_comparator = <a class="code" href="serial__listener_8cc.html#ab006cfbf3f85195f640eb367a8d6fc18">defaultComparator</a>;
  <a class="code" href="namespaceserial.html#a32362eeeed30a7d8ccadf5204e07ca2e">DataCallback</a> tmp = boost::bind(&amp;SerialListener::default_handler, <span class="keyword">this</span>, _1);
  this-&gt;default_filter = <a class="code" href="namespaceserial.html#acf64ada2e2976afe74771b22e738510b">FilterPtr</a>(<span class="keyword">new</span> <a class="code" href="classserial_1_1_filter.html">Filter</a>(default_comparator, tmp));

  <span class="comment">// Set default tokenizer</span>
  this-&gt;<a class="code" href="classserial_1_1_serial_listener.html#a0cc4f2509f44a60b08422c1fd46c87a5">setTokenizer</a>(<a class="code" href="classserial_1_1_serial_listener.html#ae71cef30bed4a80148e7480904d8852f">delimeter_tokenizer</a>(<span class="stringliteral">&quot;\r&quot;</span>));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a235ede7ea8530364d6510f0a2de068b3"></a><!-- doxytag: member="serial::SerialListener::~SerialListener" ref="a235ede7ea8530364d6510f0a2de068b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SerialListener::~SerialListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>
<div class="fragment"><pre class="fragment">                                {
  <span class="keywordflow">if</span> (this-&gt;listening) {
    this-&gt;<a class="code" href="classserial_1_1_serial_listener.html#a7587b228f9327d9c0c6b83d46a932f93">stopListening</a>();
  }
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a178ac4d1d2651341d96dc6a2d201629b"></a><!-- doxytag: member="serial::SerialListener::contains" ref="a178ac4d1d2651341d96dc6a2d201629b" args="(std::string substr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a> serial::SerialListener::contains </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>substr</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This returns a comparator that looks for a given substring in the token.</p>
<p>This can be used with listenFor or listenForOnce:</p>
<p>Example: </p>
<pre>
   my_listener.listenFor(<a class="el" href="classserial_1_1_serial_listener.html#a178ac4d1d2651341d96dc6a2d201629b">SerialListener::contains</a>("some string"),
                         my_callback);
 &lt;</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>&gt;</dd></dl>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">substr</td><td>A std::string that is used as the search substring to match 
 when comparing tokens for matching.</td></tr>
  </table>
  </dd>
</dl>
 <dl class="return"><dt><b>Returns:</b></dt><dd> ComparatorType A comparator function type that can be passed to 
 SerialListener::listenFor or SerialListener::listenForOnce.</dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd> SerialListener::listenFor, SerialListener::listenForOnce, 
 <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">serial::ComparatorType</a>
</dd></dl>
</pre><div class="fragment"><pre class="fragment">                              {
    <span class="keywordflow">return</span> boost::bind(_contains, _1, substr);
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a75d4f93598f17352072c3fc03a8a3bdb"></a><!-- doxytag: member="serial::SerialListener::createBlockingFilter" ref="a75d4f93598f17352072c3fc03a8a3bdb" args="(ComparatorType comparator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceserial.html#a99b797cbc8375c64b5e100c5f0350198">BlockingFilterPtr</a> SerialListener::createBlockingFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a>&#160;</td>
          <td class="paramname"><em>comparator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="classserial_1_1_blocking_filter.html">BlockingFilter</a> which blocks until the comparator returns true.</p>
<p>The user provides a comparator, and every time a line is received the comparator is called and the comparator has to evaluate the line and return true if it matches and false if it doesn't. If it does match, any threads that have called <a class="el" href="classserial_1_1_blocking_filter.html#a83b3ba42ef702b9e2104331b829f7027">BlockingFilter::wait</a> will be notified. The <a class="el" href="classserial_1_1_blocking_filter.html">BlockingFilter</a> will remove itself when its destructor is called, i.e. when it leaves the scope, so in those cases an explicit call to <a class="el" href="classserial_1_1_serial_listener.html#afaea45fa5ef9c172dcd6b30f65bbc065">SerialListener::removeFilter</a> is not needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>This is a comparator for detecting if a line matches. The comparartor receives a std::string reference and must return a true if it matches and false if it doesn't.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>BlockingFilterPtr So you can call <a class="el" href="classserial_1_1_blocking_filter.html#a83b3ba42ef702b9e2104331b829f7027">BlockingFilter::wait</a> on it.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classserial_1_1_serial_listener.html#afaea45fa5ef9c172dcd6b30f65bbc065">SerialListener::removeFilter</a>, <a class="el" href="classserial_1_1_blocking_filter.html">serial::BlockingFilter</a>, <a class="el" href="namespaceserial.html#a99b797cbc8375c64b5e100c5f0350198">serial::BlockingFilterPtr</a> </dd></dl>
<div class="fragment"><pre class="fragment">                                                              {
  <span class="keywordflow">return</span> <a class="code" href="namespaceserial.html#a99b797cbc8375c64b5e100c5f0350198">BlockingFilterPtr</a>(
    <span class="keyword">new</span> <a class="code" href="classserial_1_1_blocking_filter.html">BlockingFilter</a>(comparator, (*<span class="keyword">this</span>)));
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac8637a6cda1ffbf415a28d4838fb2abf"></a><!-- doxytag: member="serial::SerialListener::createBufferedFilter" ref="ac8637a6cda1ffbf415a28d4838fb2abf" args="(ComparatorType comparator, size_t buffer_size=1024)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceserial.html#a9e39a50ed4648208addac53759378497">BufferedFilterPtr</a> SerialListener::createBufferedFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a>&#160;</td>
          <td class="paramname"><em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="classserial_1_1_blocking_filter.html">BlockingFilter</a> blocks until the comparator returns true.</p>
<p>The user provides a comparator, and every time a line is received the comparator is called and the comparator has to evaluate the line and return true if it matches and false if it doesn't. If it does match, any threads that have called <a class="el" href="classserial_1_1_blocking_filter.html#a83b3ba42ef702b9e2104331b829f7027">BlockingFilter::wait</a> will be notified. The <a class="el" href="classserial_1_1_blocking_filter.html">BlockingFilter</a> will remove itself when its destructor is called, i.e. when it leaves the scope, so in those cases an explicit call to <a class="el" href="classserial_1_1_serial_listener.html#afaea45fa5ef9c172dcd6b30f65bbc065">SerialListener::removeFilter</a> is not needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>This is a comparator for detecting if a line matches. The comparartor receives a std::string reference and must return a true if it matches and false if it doesn't.</td></tr>
    <tr><td class="paramname">buffer_size</td><td>This is the number of tokens to be buffered by the <a class="el" href="classserial_1_1_buffered_filter.html">BufferedFilter</a>, defaults to 1024.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classserial_1_1_blocking_filter.html">BlockingFilter</a> So you can call <a class="el" href="classserial_1_1_blocking_filter.html#a83b3ba42ef702b9e2104331b829f7027">BlockingFilter::wait</a> on it.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classserial_1_1_serial_listener.html#afaea45fa5ef9c172dcd6b30f65bbc065">SerialListener::removeFilter</a>, <a class="el" href="classserial_1_1_buffered_filter.html">serial::BufferedFilter</a>, <a class="el" href="namespaceserial.html#a9e39a50ed4648208addac53759378497">serial::BufferedFilterPtr</a> </dd></dl>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="namespaceserial.html#a9e39a50ed4648208addac53759378497">BufferedFilterPtr</a>(
    <span class="keyword">new</span> <a class="code" href="classserial_1_1_buffered_filter.html">BufferedFilter</a>(comparator, buffer_size, (*<span class="keyword">this</span>)));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a62c0003bdaca5670eaf7d2c38273e3be"></a><!-- doxytag: member="serial::SerialListener::createFilter" ref="a62c0003bdaca5670eaf7d2c38273e3be" args="(ComparatorType comparator, DataCallback callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceserial.html#acf64ada2e2976afe74771b22e738510b">FilterPtr</a> SerialListener::createFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a>&#160;</td>
          <td class="paramname"><em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#a32362eeeed30a7d8ccadf5204e07ca2e">DataCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a filter that calls a callback when the comparator returns true.</p>
<p>The user provides a comparator and a callback, and every time a line is received the comparator is called and the comparator has to evaluate the line and return true if it matches and false if it doesn't. If it does match, the callback is called with the resulting line.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>This is a comparator for detecting if a line matches. The comparartor receives a std::string reference and must return a true if it matches and false if it doesn't.</td></tr>
    <tr><td class="paramname">callback</td><td>This is the handler for when a match occurs. It is given a std::string reference of the line that matched your comparator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>boost::shared_ptr&lt;Filter&gt; so you can remove it later.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classserial_1_1_serial_listener.html#afaea45fa5ef9c172dcd6b30f65bbc065">SerialListener::removeFilter</a> </dd></dl>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceserial.html#acf64ada2e2976afe74771b22e738510b">FilterPtr</a> filter_ptr(<span class="keyword">new</span> <a class="code" href="classserial_1_1_filter.html">Filter</a>(comparator, callback));

  boost::mutex::scoped_lock l(filter_mux);
  this-&gt;filters.push_back(filter_ptr);

  <span class="keywordflow">return</span> filter_ptr;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae71cef30bed4a80148e7480904d8852f"></a><!-- doxytag: member="serial::SerialListener::delimeter_tokenizer" ref="ae71cef30bed4a80148e7480904d8852f" args="(std::string delimeter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceserial.html#a71c86cd8a6283d8015a7941890d38ba3">TokenizerType</a> serial::SerialListener::delimeter_tokenizer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimeter</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This returns a tokenizer that splits on a given delimeter.</p>
<p>The delimeter is passed into the function and a TokenizerType is returned that can be passed to <a class="el" href="classserial_1_1_serial_listener.html#a0cc4f2509f44a60b08422c1fd46c87a5">SerialListener::setTokenizer</a>.</p>
<p>Example: </p>
<pre>
   my_listener.setTokenizer(<a class="el" href="classserial_1_1_serial_listener.html#ae71cef30bed4a80148e7480904d8852f">SerialListener::delimeter_tokenizer</a>("\r"));
 &lt;</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>&gt;</dd></dl>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">delimeter</td><td>A std::string that is used as a delimeter when 
 tokenizing data.</td></tr>
  </table>
  </dd>
</dl>
 <dl class="return"><dt><b>Returns:</b></dt><dd> TokenizerType A tokenizer function type that can be passed to 
 <a class="el" href="classserial_1_1_serial_listener.html#a0cc4f2509f44a60b08422c1fd46c87a5">SerialListener::setTokenizer</a>.</dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd> <a class="el" href="classserial_1_1_serial_listener.html#a0cc4f2509f44a60b08422c1fd46c87a5">SerialListener::setTokenizer</a>, <a class="el" href="namespaceserial.html#a71c86cd8a6283d8015a7941890d38ba3">serial::TokenizerType</a>
</dd></dl>
</pre><div class="fragment"><pre class="fragment">                                            {
    <span class="keywordflow">return</span> boost::bind(&amp;SerialListener::_delimeter_tokenizer,
                       _1, _2, delimeter);
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a22d8e22dbe6f3d35a7863c9279c4af68"></a><!-- doxytag: member="serial::SerialListener::endsWith" ref="a22d8e22dbe6f3d35a7863c9279c4af68" args="(std::string postfix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a> serial::SerialListener::endsWith </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>postfix</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This returns a comparator that looks for a given postfix.</p>
<p>This can be used with listenFor or listenForOnce:</p>
<p>Example: </p>
<pre>
   my_listener.listenFor(<a class="el" href="classserial_1_1_serial_listener.html#a22d8e22dbe6f3d35a7863c9279c4af68">SerialListener::endsWith</a>(";"), my_callback);
 &lt;</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>&gt;</dd></dl>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">postfix</td><td>A std::string that is used as the postfix string to match 
 when comparing tokens for matching.</td></tr>
  </table>
  </dd>
</dl>
 <dl class="return"><dt><b>Returns:</b></dt><dd> ComparatorType A comparator function type that can be passed to 
 SerialListener::listenFor or SerialListener::listenForOnce.</dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd> SerialListener::listenFor, SerialListener::listenForOnce, 
 <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">serial::ComparatorType</a>
</dd></dl>
</pre><div class="fragment"><pre class="fragment">                               {
    <span class="keywordflow">return</span> boost::bind(&amp;SerialListener::_endsWith, _1, postfix);
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a091cb7d1f6c53761abb832c914a4da38"></a><!-- doxytag: member="serial::SerialListener::exactly" ref="a091cb7d1f6c53761abb832c914a4da38" args="(std::string exact_str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a> serial::SerialListener::exactly </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>exact_str</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This returns a comparator that matches only the exact string given.</p>
<p>This can be used with listenFor or listenForOnce:</p>
<p>Example: </p>
<pre>
   my_listener.listenFor(<a class="el" href="classserial_1_1_serial_listener.html#a091cb7d1f6c53761abb832c914a4da38">SerialListener::exactly</a>("my_string"),
                         my_callback);
 &lt;</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>&gt;</dd></dl>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">exact_str</td><td>A std::string that is used as the exact string to match 
 when comparing tokens for matching.</td></tr>
  </table>
  </dd>
</dl>
 <dl class="return"><dt><b>Returns:</b></dt><dd> ComparatorType A comparator function type that can be passed to 
 SerialListener::listenFor or SerialListener::listenForOnce.</dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd> SerialListener::listenFor, SerialListener::listenForOnce, 
 <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">serial::ComparatorType</a>
</dd></dl>
</pre><div class="fragment"><pre class="fragment">                                {
    <span class="keywordflow">return</span> boost::bind(&amp;SerialListener::_exactly, _1, exact_str);
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ac9310aed9039d060bb72caf7d1a19fa1"></a><!-- doxytag: member="serial::SerialListener::removeAllFilters" ref="ac9310aed9039d060bb72caf7d1a19fa1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialListener::removeAllFilters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all filters. </p>
<div class="fragment"><pre class="fragment">                                 {
  boost::mutex::scoped_lock l(filter_mux);
  filters.clear();
  callback_queue.<a class="code" href="classserial_1_1_concurrent_queue.html#a9776dbfab3a45bef2fe61460a9ce00ec">clear</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="afaea45fa5ef9c172dcd6b30f65bbc065"></a><!-- doxytag: member="serial::SerialListener::removeFilter" ref="afaea45fa5ef9c172dcd6b30f65bbc065" args="(FilterPtr filter_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialListener::removeFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#acf64ada2e2976afe74771b22e738510b">FilterPtr</a>&#160;</td>
          <td class="paramname"><em>filter_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes a filter by a given FilterPtr.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filter_ptr</td><td>A shared pointer to the filter to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classserial_1_1_serial_listener.html#a62c0003bdaca5670eaf7d2c38273e3be">SerialListener::createFilter</a> </dd></dl>
<div class="fragment"><pre class="fragment">                                                 {
  boost::mutex::scoped_lock l(filter_mux);
  filters.erase(std::find(filters.begin(),filters.end(),filter_ptr));
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa231e15eb061b74e165b96a2c68548c8"></a><!-- doxytag: member="serial::SerialListener::removeFilter" ref="aa231e15eb061b74e165b96a2c68548c8" args="(BlockingFilterPtr blocking_filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialListener::removeFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#a99b797cbc8375c64b5e100c5f0350198">BlockingFilterPtr</a>&#160;</td>
          <td class="paramname"><em>blocking_filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes a <a class="el" href="classserial_1_1_blocking_filter.html">BlockingFilter</a>.</p>
<p>The <a class="el" href="classserial_1_1_blocking_filter.html">BlockingFilter</a> will remove itself if the destructor is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">blocking_filter</td><td>A <a class="el" href="classserial_1_1_blocking_filter.html">BlockingFilter</a> to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classserial_1_1_serial_listener.html#a75d4f93598f17352072c3fc03a8a3bdb">SerialListener::createBlockingFilter</a> </dd></dl>
<div class="fragment"><pre class="fragment">                                                              {
  this-&gt;<a class="code" href="classserial_1_1_serial_listener.html#afaea45fa5ef9c172dcd6b30f65bbc065">removeFilter</a>(blocking_filter-&gt;filter_ptr);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a15b39e4392cf4cec1e1b08e4f198e5fd"></a><!-- doxytag: member="serial::SerialListener::removeFilter" ref="a15b39e4392cf4cec1e1b08e4f198e5fd" args="(BufferedFilterPtr buffered_filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialListener::removeFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#a9e39a50ed4648208addac53759378497">BufferedFilterPtr</a>&#160;</td>
          <td class="paramname"><em>buffered_filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes a <a class="el" href="classserial_1_1_buffered_filter.html">BufferedFilter</a>.</p>
<p>The <a class="el" href="classserial_1_1_buffered_filter.html">BufferedFilter</a> will remove itself if the destructor is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffered_filter</td><td>A <a class="el" href="classserial_1_1_buffered_filter.html">BufferedFilter</a> to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classserial_1_1_serial_listener.html#ac8637a6cda1ffbf415a28d4838fb2abf">SerialListener::createBufferedFilter</a> </dd></dl>
<div class="fragment"><pre class="fragment">                                                              {
  this-&gt;<a class="code" href="classserial_1_1_serial_listener.html#afaea45fa5ef9c172dcd6b30f65bbc065">removeFilter</a>(buffered_filter-&gt;filter_ptr);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a54613d3c6ffa4015db14e5ca95f0d541"></a><!-- doxytag: member="serial::SerialListener::setChunkSize" ref="a54613d3c6ffa4015db14e5ca95f0d541" args="(size_t chunk_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serial::SerialListener::setChunkSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chunk_size</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the number of bytes to be read at a time by the listener.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk_size</td><td>Number of bytes to be read at a time. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">                                   {
    this-&gt;chunk_size_ = chunk_size;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a7e130dedfb5e934ced941df64726b5c8"></a><!-- doxytag: member="serial::SerialListener::setDebugHandler" ref="a7e130dedfb5e934ced941df64726b5c8" args="(LoggingCallback debug_handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serial::SerialListener::setDebugHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#af0057921550e0544822f8cc552c77e05">LoggingCallback</a>&#160;</td>
          <td class="paramname"><em>debug_handler</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the function to be called when a debug logging message occurs.</p>
<p>This allows you to hook into the message reporting of the library and use your own logging facilities.</p>
<p>This works just like <a class="el" href="classserial_1_1_serial_listener.html#a247714b1dbf65ee6d74418a1990a4062">SerialListener::setInfoHandler</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">debug_handler</td><td>A function pointer to the callback to handle new Debug messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceserial.html#af0057921550e0544822f8cc552c77e05">serial::LoggingCallback</a>, <a class="el" href="classserial_1_1_serial_listener.html#a247714b1dbf65ee6d74418a1990a4062">SerialListener::setInfoHandler</a> </dd></dl>
<div class="fragment"><pre class="fragment">                                                  {
    this-&gt;debug = debug_handler;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ac71a68d0a96799b30ef4cbadbbb5a020"></a><!-- doxytag: member="serial::SerialListener::setDefaultHandler" ref="ac71a68d0a96799b30ef4cbadbbb5a020" args="(DataCallback default_handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serial::SerialListener::setDefaultHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#a32362eeeed30a7d8ccadf5204e07ca2e">DataCallback</a>&#160;</td>
          <td class="paramname"><em>default_handler</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the handler to be called when a lines is not caught by a filter.</p>
<p>This allows you to set a catch all function that will get called everytime a line is not matched by a filter and the ttl expires.</p>
<p>Setting the callbacks works just like <a class="el" href="classserial_1_1_serial_listener.html#a247714b1dbf65ee6d74418a1990a4062">SerialListener::setInfoHandler</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">default_handler</td><td>A function pointer to the callback to handle unmatched and expired messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceserial.html#a32362eeeed30a7d8ccadf5204e07ca2e">serial::DataCallback</a>, <a class="el" href="classserial_1_1_serial_listener.html#a247714b1dbf65ee6d74418a1990a4062">SerialListener::setInfoHandler</a> </dd></dl>
<div class="fragment"><pre class="fragment">                                                   {
    this-&gt;_default_handler = default_handler;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a247714b1dbf65ee6d74418a1990a4062"></a><!-- doxytag: member="serial::SerialListener::setInfoHandler" ref="a247714b1dbf65ee6d74418a1990a4062" args="(LoggingCallback info_handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serial::SerialListener::setInfoHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#af0057921550e0544822f8cc552c77e05">LoggingCallback</a>&#160;</td>
          <td class="paramname"><em>info_handler</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the function to be called when an info logging message occurs.</p>
<p>This allows you to hook into the message reporting of the library and use your own logging facilities.</p>
<p>The provided function must follow this prototype: </p>
<pre>
    void yourInfoCallback(const std::string &amp;msg)
 </pre><p> Here is an example: </p>
<pre>
    void yourInfoCallback(const std::string &amp;msg) {
        std::cout &lt;&lt; "SerialListener Info: " &lt;&lt; msg &lt;&lt; std::endl;
    }
 </pre><p> And the resulting call to make it the callback: </p>
<pre>
    <a class="el" href="classserial_1_1_serial_listener.html">serial::SerialListener</a> listener;
    listener.setInfoCallback(yourInfoCallback);
 </pre><p> Alternatively you can use a class method as a callback using boost::bind: </p>
<pre>
    #include &lt;boost/bind.hpp&gt;</pre><pre>    #include "serial/serial_listener.h"</pre><pre>    class MyClass
    {
    public:
     MyClass () {
      listener.setInfoHandler(
          boost::bind(&amp;MyClass::handleInfo, this, _1));
     }</pre><pre>     void handleInfo(const std::string &amp;msg) {
       std::cout &lt;&lt; "MyClass Info: " &lt;&lt; msg &lt;&lt; std::endl;
     }</pre><pre>    private:
     <a class="el" href="classserial_1_1_serial_listener.html">serial::SerialListener</a> listener;
    };
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">info_handler</td><td>A function pointer to the callback to handle new Info messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceserial.html#af0057921550e0544822f8cc552c77e05">serial::LoggingCallback</a> </dd></dl>
<div class="fragment"><pre class="fragment">                                                {
    this-&gt;info = info_handler;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a0cc4f2509f44a60b08422c1fd46c87a5"></a><!-- doxytag: member="serial::SerialListener::setTokenizer" ref="a0cc4f2509f44a60b08422c1fd46c87a5" args="(TokenizerType tokenizer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serial::SerialListener::setTokenizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#a71c86cd8a6283d8015a7941890d38ba3">TokenizerType</a>&#160;</td>
          <td class="paramname"><em>tokenizer</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the tokenizer to be used when tokenizing the data into tokens.</p>
<p>This function is given a std::string of data and is responsible for tokenizing that data into a std::vector&lt;TokenPtr&gt; of data tokens. The default tokenizer splits the data by the ascii return carriage. The user can create their own tokenizer or use one of the default ones.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tokenizer</td><td>Function for tokenizing the incoming data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceserial.html#a71c86cd8a6283d8015a7941890d38ba3">serial::TokenizerType</a>, serial::delimeter_tokenizer </dd></dl>
<div class="fragment"><pre class="fragment">                                         {
    this-&gt;tokenize = tokenizer;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ac7094b1def26041f92f05c1c4a1d65c9"></a><!-- doxytag: member="serial::SerialListener::setWarningHandler" ref="ac7094b1def26041f92f05c1c4a1d65c9" args="(LoggingCallback warning_handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serial::SerialListener::setWarningHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserial.html#af0057921550e0544822f8cc552c77e05">LoggingCallback</a>&#160;</td>
          <td class="paramname"><em>warning_handler</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the function to be called when a warning logging message occurs.</p>
<p>This allows you to hook into the message reporting of the library and use your own logging facilities.</p>
<p>This works just like <a class="el" href="classserial_1_1_serial_listener.html#a247714b1dbf65ee6d74418a1990a4062">SerialListener::setInfoHandler</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">warning_handler</td><td>A function pointer to the callback to handle new Warning messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceserial.html#af0057921550e0544822f8cc552c77e05">serial::LoggingCallback</a>, <a class="el" href="classserial_1_1_serial_listener.html#a247714b1dbf65ee6d74418a1990a4062">SerialListener::setInfoHandler</a> </dd></dl>
<div class="fragment"><pre class="fragment">                                                      {
    this-&gt;warn = warning_handler;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ab2248f5520af44280175104d42729713"></a><!-- doxytag: member="serial::SerialListener::sleep" ref="ab2248f5520af44280175104d42729713" args="(long milliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void serial::SerialListener::sleep </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sleeps for a given number of milliseconds.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>number of milliseconds to sleep. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">                            {
    boost::int64_t ms(milliseconds);
    <a class="code" href="classserial_1_1_serial_listener.html#ab2248f5520af44280175104d42729713">boost::this_thread::sleep</a>(boost::posix_time::milliseconds(ms));
  }
</pre></div>
</div>
</div>
<a class="anchor" id="aa17f7ac85c36e59c61d443f98736a8d9"></a><!-- doxytag: member="serial::SerialListener::startListening" ref="aa17f7ac85c36e59c61d443f98736a8d9" args="(serial::Serial &amp;serial_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialListener::startListening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classserial_1_1_serial.html">serial::Serial</a> &amp;&#160;</td>
          <td class="paramname"><em>serial_port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts a thread to listen for messages and process them through filters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">serial_port</td><td>Pointer to a <a class="el" href="namespaceserial_1_1serial_1_1_serial.html">serial::Serial</a> object that is used to retrieve new data. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">                                                  {
  <span class="keywordflow">if</span> (this-&gt;listening) {
    <span class="keywordflow">throw</span>(<a class="code" href="classserial_1_1_serial_listener_exception.html">SerialListenerException</a>(<span class="stringliteral">&quot;Already listening.&quot;</span>));
    <span class="keywordflow">return</span>;
  }
  this-&gt;listening = <span class="keyword">true</span>;
  
  this-&gt;serial_port_ = &amp;serial_port;
  <span class="keywordflow">if</span> (!this-&gt;serial_port_-&gt;<a class="code" href="classserial_1_1_serial.html#af9895af496189f7f0aba7c097f5fa9c1">isOpen</a>()) {
    <span class="keywordflow">throw</span>(<a class="code" href="classserial_1_1_serial_listener_exception.html">SerialListenerException</a>(<span class="stringliteral">&quot;Serial port not open.&quot;</span>));
    <span class="keywordflow">return</span>;
  }
  
  listen_thread = boost::thread(boost::bind(&amp;SerialListener::listen, <span class="keyword">this</span>));
  
  <span class="comment">// Start the callback thread</span>
  callback_thread =
   boost::thread(boost::bind(&amp;SerialListener::callback, <span class="keyword">this</span>));
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac6039844ba46665ed83e3885849b4d1d"></a><!-- doxytag: member="serial::SerialListener::startsWith" ref="ac6039844ba46665ed83e3885849b4d1d" args="(std::string prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">ComparatorType</a> serial::SerialListener::startsWith </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This returns a comparator that looks for a given prefix.</p>
<p>This can be used with listenFor or listenForOnce:</p>
<p>Example: </p>
<pre>
   my_listener.listenFor(<a class="el" href="classserial_1_1_serial_listener.html#ac6039844ba46665ed83e3885849b4d1d">SerialListener::startsWith</a>("V="), my_callback);
 &lt;</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>&gt;</dd></dl>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>A std::string that is used as the prefix string to match 
 when comparing tokens for matching.</td></tr>
  </table>
  </dd>
</dl>
 <dl class="return"><dt><b>Returns:</b></dt><dd> ComparatorType A comparator function type that can be passed to 
 SerialListener::listenFor or SerialListener::listenForOnce.</dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd> SerialListener::listenFor, SerialListener::listenForOnce, 
 <a class="el" href="namespaceserial.html#a614a7287e4bfb6394b45e5cb0ea193cc">serial::ComparatorType</a>
</dd></dl>
</pre><div class="fragment"><pre class="fragment">                                {
    <span class="keywordflow">return</span> boost::bind(&amp;SerialListener::_startsWith, _1, prefix);
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a7587b228f9327d9c0c6b83d46a932f93"></a><!-- doxytag: member="serial::SerialListener::stopListening" ref="a7587b228f9327d9c0c6b83d46a932f93" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialListener::stopListening </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stops the listening thread and blocks until it completely stops.</p>
<p>This function also clears all of the active filters from listenFor and similar functions. </p>
<div class="fragment"><pre class="fragment">                              {
  <span class="comment">// Stop listening and clear buffers</span>
  listening = <span class="keyword">false</span>;

  listen_thread.join();
  callback_thread.join();

  this-&gt;data_buffer = <span class="stringliteral">&quot;&quot;</span>;
  this-&gt;serial_port_ = NULL;

  <span class="comment">// Delete all the filters</span>
  this-&gt;<a class="code" href="classserial_1_1_serial_listener.html#ac9310aed9039d060bb72caf7d1a19fa1">removeAllFilters</a>();
}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/serial/<a class="el" href="serial__listener_8h_source.html">serial_listener.h</a></li>
<li>src/<a class="el" href="serial__listener_8cc.html">serial_listener.cc</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 13 2012 11:05:30 for serial by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
